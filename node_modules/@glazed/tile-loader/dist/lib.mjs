import"setimmediate";import{TileDocument as h}from"@ceramicnetwork/stream-tile";import{CommitID as l,StreamID as u,StreamRef as I}from"@ceramicnetwork/streamid";import _ from"dataloader";var f=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},m=(e,t,r)=>(f(e,t,"read from private field"),r?r.call(e):t.get(e)),p=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},w=(e,t,r,a)=>(f(e,t,"write to private field"),a?a.call(e,r):t.set(e,r),r),c,o;function v(e){return typeof e=="string"||l.isInstance(e)||u.isInstance(e)?{streamId:e}:{streamId:e.streamId,genesis:e.genesis}}function d(e){return typeof e=="string"?I.from(e).toString():l.isInstance(e)||u.isInstance(e)?e.toString():e.streamId.toString()}async function g(e){const t=await h.makeGenesis({},null,{...e,deterministic:!0}),r=await u.fromGenesis("tile",t);return{genesis:t,streamId:r}}const S=()=>Promise.resolve([]);class y extends _{constructor(t){super(S,{cache:!0,cacheKeyFn:d,cacheMap:t.cache!=null&&typeof t.cache!="boolean"?t.cache:void 0});p(this,c,void 0),p(this,o,void 0),this._batchLoadFn=async r=>{t.cache||this.clearAll();const a=await t.ceramic.multiQuery(r.map(v));return r.map(n=>{const i=d(n),s=a[i];return s||new Error(`Failed to load stream: ${i}`)})},w(this,c,t.ceramic),w(this,o,!!t.cache)}cache(t){if(!m(this,o))return!1;const r=t.id.toString();return this.clear(r).prime(r,t),!0}async create(t,r,a){const n=await h.create(m(this,c),t,r,a);return this.cache(n),n}async deterministic(t,r){const a=await g(t);try{return await super.load(a)}catch{const i=await h.createFromGenesis(m(this,c),a.genesis,r);return this.cache(i),i}}async load(t){return await super.load(t)}async update(t,r,a,n){const i=d(t);this.clear(i);const s=await this.load({streamId:i});return await s.update(r,a,n),s}}c=new WeakMap,o=new WeakMap;export{y as TileLoader,g as getDeterministicQuery,v as keyToQuery,d as keyToString};
//# sourceMappingURL=lib.mjs.map
