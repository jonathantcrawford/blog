"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var U=require("@ceramicnetwork/streamid"),v=require("@glazed/constants"),E=require("@glazed/datamodel"),k=require("@glazed/tile-loader"),S=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)},l=(n,t,e)=>(S(n,t,"read from private field"),e?e.call(n):t.get(n)),R=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},x=(n,t,e,i)=>(S(n,t,"write to private field"),i?i.call(n,e):t.set(n,e),e),_,w,P,D;class q{constructor(t){R(this,_,void 0),R(this,w,[]),R(this,P,void 0),R(this,D,void 0),x(this,_,t),this._createValuePromise()}_createValuePromise(){x(this,P,new Promise((t,e)=>{x(this,D,{resolve:t,reject:e})}))}change(t){return new Promise((e,i)=>{const r=async a=>{try{const s=await t(a);e(),this._next(s)}catch(s){i(s),this._next(a)}};l(this,w).push({reject:i,run:r}),l(this,w).length===1&&this._start()})}async changeContent(t){const e=async i=>(await i.update(t(i.content),i.metadata),i);return await this.change(e)}async get(){return l(this,w).length===0?await l(this,_).call(this):await l(this,P)}async _start(){try{const t=await l(this,_).call(this);this._next(t)}catch(t){l(this,w).forEach(e=>{e.reject(t)}),x(this,w,[]),l(this,D).reject(t),this._createValuePromise()}}_next(t){const e=l(this,w).shift();e==null?this._end(t):e.run(t)}_end(t){l(this,D).resolve(t),this._createValuePromise()}}_=new WeakMap,w=new WeakMap,P=new WeakMap,D=new WeakMap;const L=/^did:([A-Za-z0-9]+):([A-Za-z0-9.\-:_]+)$/;function O(n){return L.test(n)}function W(n){if(!O(n))throw new Error(`Invalid DID: ${n}`)}function X(n){return W(n),{controllers:[n],family:"IDX"}}var A=(n,t,e)=>{if(!t.has(n))throw TypeError("Cannot "+e)},o=(n,t,e)=>(A(n,t,"read from private field"),e?e.call(n):t.get(n)),g=(n,t,e)=>{if(t.has(n))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(n):t.set(n,e)},I=(n,t,e,i)=>(A(n,t,"write to private field"),i?i.call(n,e):t.set(n,e),e),y,f,m,C,h,p;class T{constructor(t){g(this,y,void 0),g(this,f,void 0),g(this,m,void 0),g(this,C,{}),g(this,h,void 0),g(this,p,void 0);const{autopin:e,cache:i,ceramic:r,id:a,loader:s,model:c}=t;I(this,y,e!==!1),I(this,f,r),I(this,m,a),I(this,h,s??new k.TileLoader({ceramic:r,cache:i})),I(this,p,c instanceof E.DataModel?c:new E.DataModel({autopin:e,loader:o(this,h),model:c}))}get authenticated(){return o(this,f).did!=null}get ceramic(){return o(this,f)}get id(){if(o(this,m)!=null)return o(this,m);if(o(this,f).did==null)throw new Error("Ceramic instance is not authenticated");return o(this,f).did.id}get loader(){return o(this,h)}get model(){return o(this,p)}async has(t,e){const i=this.getDefinitionID(t);return await this.getRecordID(i,e)!=null}async get(t,e){const i=this.getDefinitionID(t);return await this.getRecord(i,e)}async getMultiple(t,e){const i=this.getDefinitionID(t),r=await Promise.all(e.map(async c=>{const{genesis:d,streamId:u}=await k.getDeterministicQuery(X(c));return{genesis:d,streamId:u.toString(),paths:[i]}})),a=await o(this,f).multiQuery(r),s=[];for(const c of r){const d=a[c.streamId]?.content?.[i],u=d?a[U.StreamID.fromString(d).toString()]:null;s.push(u?.content??null)}return s}async set(t,e,i={}){const r=this.getDefinitionID(t),[a,s]=await this._setRecordOnly(r,e,i);return a&&await this._setReference(i.controller??this.id,r,s),s}async merge(t,e,i={}){const r=this.getDefinitionID(t),a=await this.getRecord(r),s=a?{...a,...e}:e;return await this.setRecord(r,s,i)}async setAll(t,e={}){const i=Object.entries(t).map(async([s,c])=>{const d=this.getDefinitionID(s),[u,M]=await this._setRecordOnly(d,c,e);return[u,d,M]}),a=(await Promise.all(i)).reduce((s,[c,d,u])=>(c&&(s[d]=u.toUrl()),s),{});return await this._setReferences(e.controller??this.id,a),a}async setDefaults(t,e={}){const i=await this.getIndex()??{},r=Object.entries(t).map(([c,d])=>[this.getDefinitionID(c),d]).filter(c=>i[c[0]]==null).map(async([c,d])=>{const u=await this.getDefinition(c),M=await this._createRecord(u,d,e);return{[c]:M.toUrl()}}),s=(await Promise.all(r)).reduce((c,d)=>Object.assign(c,d),{});return await this._setReferences(e.controller??this.id,s),s}async remove(t,e=this.id){await this._getIndexProxy(e).changeContent(i=>(i!=null&&delete i[this.getDefinitionID(t)],i))}async getIndex(t=this.id){const e=this.authenticated&&t===this.id?await this._getIndexProxy(t).get():await this._getIDXDoc(t);return e?e.content:null}iterator(t){let e,i=0;return{[Symbol.asyncIterator](){return this},next:async()=>{if(e==null){const c=await this.getIndex(t);e=Object.entries(c??{})}if(i===e.length)return{done:!0,value:null};const[r,a]=e[i++],s=await o(this,h).load(a);return{done:!1,value:{key:r,id:a,record:s.content}}}}}async _createIDXDoc(t){return await o(this,h).deterministic(X(t))}async _getIDXDoc(t){const e=await this._createIDXDoc(t);if(e.content==null||e.metadata.schema==null)return null;if(e.metadata.schema!==v.CIP11_INDEX_SCHEMA_URL)throw new Error("Invalid document: schema is not IdentityIndex");return e}async _getOwnIDXDoc(t){const e=await this._createIDXDoc(t);if(e.content==null||e.metadata.schema==null)await e.update({},{schema:v.CIP11_INDEX_SCHEMA_URL},{pin:o(this,y)});else if(e.metadata.schema!==v.CIP11_INDEX_SCHEMA_URL)throw new Error("Invalid document: schema is not IdentityIndex");return e}_getIndexProxy(t){let e=o(this,C)[t];return e==null&&(e=new q(async()=>await this._getOwnIDXDoc(t)),o(this,C)[t]=e),e}getDefinitionID(t){return o(this,p).getDefinitionID(t)??t}async getDefinition(t){const e=await o(this,h).load(t);if(e.metadata.schema!==v.CIP11_DEFINITION_SCHEMA_URL)throw new Error("Invalid document: schema is not Definition");return{...e.content,id:e.id}}async getRecordID(t,e){return(await this.getIndex(e??this.id))?.[t]??null}async getRecordDocument(t,e){const i=await this.getRecordID(t,e);return i?await o(this,h).load(i):null}async getRecord(t,e){const i=await this.getRecordDocument(t,e);return i?i.content:null}async setRecord(t,e,i={}){const[r,a]=await this._setRecordOnly(t,e,i);return r&&await this._setReference(i.controller??this.id,t,a),a}async _setRecordOnly(t,e,i){const r=await this.getRecordID(t,i.controller??this.id);if(r==null){const a=await this.getDefinition(t),s=await this._createRecord(a,e,i);return[!0,s]}else{const a=await o(this,h).update(r,e);return[!1,a.id]}}async _createRecord(t,e,{controller:i,pin:r}){const a=await o(this,h).deterministic({controllers:[i??this.id],family:t.id.toString()});return await a.update(e,{schema:t.schema},{pin:r??o(this,y)}),a.id}async _setReference(t,e,i){await this._getIndexProxy(t).changeContent(r=>({...r,[e]:i.toUrl()}))}async _setReferences(t,e){Object.keys(e).length!==0&&await this._getIndexProxy(t).changeContent(i=>({...i,...e}))}}y=new WeakMap,f=new WeakMap,m=new WeakMap,C=new WeakMap,h=new WeakMap,p=new WeakMap,exports.DIDDataStore=T,exports.assertDIDstring=W,exports.isDIDstring=O;
//# sourceMappingURL=lib.cjs.map
