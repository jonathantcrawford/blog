import { __assign, __awaiter, __generator, __read, __spreadArray } from "tslib";
import { createScope, getSigningKey } from "@aws-sdk/signature-v4";
import { formatUrl } from "@aws-sdk/util-format-url";
import { toHex } from "@aws-sdk/util-hex-encoding";
import { ALGORITHM_IDENTIFIER, ALGORITHM_QUERY_PARAM, AMZ_DATE_QUERY_PARAM, CREDENTIAL_QUERY_PARAM, SIGNATURE_QUERY_PARAM, TOKEN_QUERY_PARAM, } from "./constants";
export var createPresignedPost = function (client, _a) {
    var Bucket = _a.Bucket, Key = _a.Key, _b = _a.Conditions, Conditions = _b === void 0 ? [] : _b, _c = _a.Fields, Fields = _c === void 0 ? {} : _c, _d = _a.Expires, Expires = _d === void 0 ? 3600 : _d;
    return __awaiter(void 0, void 0, void 0, function () {
        var _e, systemClockOffset, base64Encoder, utf8Decoder, sha256, now, signingDate, shortDate, clientRegion, credentialScope, clientCredentials, credential, fields, expiration, conditions, encodedPolicy, signingKey, signature, endpoint;
        var _f, _g, _h;
        return __generator(this, function (_j) {
            switch (_j.label) {
                case 0:
                    _e = client.config, systemClockOffset = _e.systemClockOffset, base64Encoder = _e.base64Encoder, utf8Decoder = _e.utf8Decoder, sha256 = _e.sha256;
                    now = new Date(Date.now() + systemClockOffset);
                    signingDate = iso8601(now).replace(/[\-:]/g, "");
                    shortDate = signingDate.slice(0, 8);
                    return [4, client.config.region()];
                case 1:
                    clientRegion = _j.sent();
                    credentialScope = createScope(shortDate, clientRegion, "s3");
                    return [4, client.config.credentials()];
                case 2:
                    clientCredentials = _j.sent();
                    credential = "".concat(clientCredentials.accessKeyId, "/").concat(credentialScope);
                    fields = __assign(__assign(__assign({}, Fields), (_f = { bucket: Bucket }, _f[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER, _f[CREDENTIAL_QUERY_PARAM] = credential, _f[AMZ_DATE_QUERY_PARAM] = signingDate, _f)), (clientCredentials.sessionToken ? (_g = {}, _g[TOKEN_QUERY_PARAM] = clientCredentials.sessionToken, _g) : {}));
                    expiration = new Date(now.valueOf() + Expires * 1000);
                    conditions = __spreadArray(__spreadArray(__spreadArray([], __read(Conditions), false), __read(Object.entries(fields).map(function (_a) {
                        var _b;
                        var _c = __read(_a, 2), k = _c[0], v = _c[1];
                        return (_b = {}, _b[k] = v, _b);
                    })), false), [
                        Key.endsWith("${filename}")
                            ? ["starts-with", "$key", Key.substring(0, Key.lastIndexOf("${filename}"))]
                            : { key: Key },
                    ], false);
                    encodedPolicy = base64Encoder(utf8Decoder(JSON.stringify({
                        expiration: iso8601(expiration),
                        conditions: conditions,
                    })));
                    return [4, getSigningKey(sha256, clientCredentials, shortDate, clientRegion, "s3")];
                case 3:
                    signingKey = _j.sent();
                    return [4, hmac(sha256, signingKey, encodedPolicy)];
                case 4:
                    signature = _j.sent();
                    return [4, client.config.endpoint()];
                case 5:
                    endpoint = _j.sent();
                    if (!client.config.bucketEndpoint) {
                        endpoint.path = "/".concat(Bucket);
                    }
                    return [2, {
                            url: formatUrl(endpoint),
                            fields: __assign(__assign({}, fields), (_h = { key: Key, Policy: encodedPolicy }, _h[SIGNATURE_QUERY_PARAM] = toHex(signature), _h)),
                        }];
            }
        });
    });
};
var iso8601 = function (date) { return date.toISOString().replace(/\.\d{3}Z$/, "Z"); };
var hmac = function (ctor, secret, data) {
    var hash = new ctor(secret);
    hash.update(data);
    return hash.digest();
};
